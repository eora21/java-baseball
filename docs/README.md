# 구현할 기능 목록

## NumberBaseball (게임을 진행)

- [x] 유저가 중단을 원할 때까지 게임을 실행한다.
- [x] 유저가 완벽한 답을 맞추기 전까지 게임을 진행한다.

## Staff (룰에 기반하여 목표값과 유저의 입력값들을 관리)

- [x] 1부터 9까지의 값을 `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms.pickNumberInRange()`를 이용해 중복 없이 3개 뽑는다.
- [ ] 사용자가 제시한 값이 규칙을 제대로 지켰을 경우 변환값을 반환한다. (규칙들은 통과되지 못 했을 경우 `IllegalArgumentException`을 발생시킨다.)
  - [ ] 세자리의 값을 제대로 입력했는가
  - [ ] Int형으로 변환이 가능한가
  - [ ] 허용되지 않은 `0`을 사용하진 않았는가
  - [ ] 각 자릿값이 중복되지 않았는가
- [ ] 유저가 새 게임을 원하는지, 종료를 원하는지 판단한다.

## Referee (게임의 결과에 대해 판단)

- [ ] 3스트라이크인지 아닌지 확인한다.
  - [ ] 입력값 3자리를 비교해 스트라이크, 볼을 판단한다.
    - [ ] 자릿값과 일치 -> 스트라이크
    - [ ] 해당 값이 목표값 내에 있는가 -> 볼
    - [ ] 볼, 스트라이크 유무에 따라 출력
  - [ ] 출력 문자를 만들어주는 메서드를 이용해 답을 맞춘 결과에 따른 문자열 생성
    - [ ] 문자열이 제대로 생성되었다면 출력, 아니라면 하나도 맞추지 못 했으므로 낫싱 출력

# 고려한 점

-  `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms`를 이용하여 1부터 9까지의 값을 3개 뽑아야 한다.
  - ~~`Randoms` 내에 `pickUniqueNumbersInRange`라는 메서드가 있다는 것을 발견하였다. 이름만 봐도 중복 없이 값을 뽑는다는 듯 했다.~~
  - ~~매개변수는 `startInclusive`, `endInclusive`, `count`가 있었다. 시작값, 끝값, 뽑을 횟수를  뜻했다.~~
  - ~~내부 코드를 확인해보니, `validateRange`로 범위 값 제한이 올바른지, `validateCount`로 count의 선언이 올바른지를 검사하고 있었다.~~
    - ~~`validateRange`는 시작값 <= 끝값 관계 및 int형에서의 최댓값을 넘어가거나 최댓값 이상의 갯수를 지니는지 확인한다.~~
    - ~~`validateCount`는 뽑을 횟수값이 음수거나 지정한 범위보다 많은지를 확인한다.~~
  - ~~입력이 올바르게 들어왔다면, 해당하는 List를 만든 뒤 시작값부터 끝값을 추가, 랜덤으로 섞은 후 앞에서부터 뽑을 횟수만큼 잘라 반환하는 형태였다.~~
  - ~~로직의 흐름을 충분히 따라갈 수 있었기에, 해당 메서드를 사용하기로 했다.~~
  - `Randoms.pickNumberInRange()`만을 활용하여 구성하여야 했다. 프로그래밍 요구 사항에 있었으나, 깜빡 지나쳐버렸었다. **요구 사항을 잘 읽자..**
-  잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시키고 종료하여야 한다.
  - 세자리인지 먼저 확인하고 변환하는게, 추후 length 관련 에러를 막을 수 있다고 판단하였다.
  - 세자리는 맞으나 공백 등 정수형으로 변경할 수 없는 경우에도 물론 띄워줘야 한다.
  - 1부터 9까지만 사용해야 하며, 값의 중복은 set으로 판단할 수 있었다.
  - 해당 구조는 `Randoms.pickUniqueNumbersInRange`의 `validateRange`, `validateCount`를 참고하였다.
-  게임의 새 시작과 종료를 구분짓는 메서드에서는 잘못된 값을 입력할 경우 재차 물어본다.
  - `종료 == 2` 라는 결정권이 주어졌을 때, `잘못된 값 입력시 종료`를 수행하게 되면 이는 곧 `1 이외 값 입력시 종료` 조건으로 변질될 수 있기 때문
-  입력값을 검사하는 부분이 맘에 들지 않아 변경해보려고 하였다.
   -  세자리의 값을 입력했는가
   -  1~9의 값만 썼는가
   -  중복된 값이 없는가

-  정규식을 사용해보려 하였으나, 우선 현재의 메서드를 구현 후 정규식을 찬찬히 공부해보기로 하였다.

# 고민한 사항

- 받은 입력값을 3자리로 변환할 수 있는지를 확인하고, 가능하다면 변환하여 검사해야 한다. 이 때, 변환하여 검사 후 이상이 없다면 반환하게끔 구성한다면.. 메서드 이름을 어떻게 지어야 할 것인가?
  - 기존 코드 작성 방향은 `값 입력` -> `제대로 된 입력인지 확인` -> `제대로 된 입력이라면 변환하여 사용` 순으로 하려 했으나, `값 입력` -> `제대로 된 입력인지 직접 변환하여 테스트, 이상 없다면 반환`으로 변경하는 게 좋을 것 같다는 생각이 들었다.
  - 그러나, 이런 구조라면 메서드명을 어떻게 지어야 할 지 난감했다. 확인받은 후 이상이 없다면 값을 반환받는 것이니, `ifValueIsAcceptable`로 하려 했는데 다른 사용자가 보고 납득할 수 있는지 감이 잘 오지 않았다. 값을 반환받는 느낌보다 확인한다는 느낌이 더 강하게 들었다.. 우선은 값을 가져온다고 표현해주는 게 먼저일 것 같아 `getValueIfAcceptable`로 적었는데, 이것도 약간 마음에 들진 않는다. 더 좋은 메서드명을 위해 고민해봐야 할 것 같다.

# 트러블 슈팅

## 경고 출력문

```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by camp.nextstep.edu.missionutils.Console (file:/C:/Users/eora2/.gradle/caches/modules-2/files-2.1/com.github.woowacourse-projects/mission-utils/1.0.0/dad5230ec970560465a42a1cade24166e6a424f4/mission-utils-1.0.0.jar) to field java.util.Scanner.sourceClosed
WARNING: Please consider reporting this to the maintainers of camp.nextstep.edu.missionutils.Console
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
```

반복문을 통해 입력을 받다가 해당 경고가 출력되었다.

구글링을 해 보니, JDK 버전과 타 라이브러리 버전이 맞지 않아 생긴 문제라고 한다.

하지만 프리코스에서는 JDK 11버전을 사용하며, `build.gradle` 파일을 변경할 수 없고, 무엇보다 **JDK 11에서 정상적으로 동작하지 않을 경우 0점 처리**를 하기에.. `일부러 이런 에러가 뜨게끔 구성한건가? 아니면 내 코드 문제일까?`에 대해 고민했다. 단순 경고창을 띄우는 거라곤 하지만.. 그래도 불안한 건 어쩔 수 없는 것 같다.

## 테스트 코드

```java
@Test
void 게임종료_후_재시작() {
    assertRandomNumberInRangeTest(
        () -> {
            run("246", "135", "1", "597", "589", "2");
            assertThat(output()).contains("낫싱", "3스트라이크", "1볼 1스트라이크", "3스트라이크", "게임 종료");
        },
        1, 3, 5, 5, 8, 9
    );
}
```

해당 구문을 보면, 답을 `135`와 `589`를 강제해놓고 코드를 돌리는 듯 했다.

헌데 `assertRandomNumberInRangeTest`의 매개변수는 `final Executable executable`, `final Integer value`, `final Integer... values`였고, 따라서 `value`에는 `1`이, `values`에는 `3, 5, 5, 8, 9`가 들어가는 형태였다.

이게 어떤 의미로 이렇게 들어간 건지, 저렇게 넣으면 값이 고정되는지 코드를 출력해봤으나, 내 코드 기준에서는 목표값으로 빈 리스트만 출력되고 있었다.

내 짧은 견해로는, `mock.when(verification).thenReturn(value, Arrays.stream(values).toArray());` 코드에서 랜덤 값을 `1, 3, 5, 5, 8, 9` 순으로 고정시키는 것 같은데, 왜 내 코드에서는 작성되지 않는지 의문이다. `pickUniqueNumbersInRange()`를 사용해서 그런 걸까?

혹시나 하는 마음에 `pickNumberInRange()`를 사용하여 코드를 돌려보았는데.. 정답이 떴다.. `프로그래밍 요구 사항` 중 `라이브러리` 항목에 `pickNumberInRange()`를 활용하라고 떡하니 적혀 있었는데, 이를 놓치고 헛고생을 하고 있었다..

반성할 시간을 가졌다. 그래도 그 과정에서 배운 것은, 역시 메서드를 쪼개 놓으니 딱 원하는 부분만 수정하여 결과를 얻어낼 수 있었다는 점이다.

또, `pickUniqueNumbersInRange()`에서는 왜 안돌아간 건지 궁금해져서 찾아보기로 했다.

### `pickUniqueNumbersInRange()`에서는 왜 안돌았을까

#### 코드를 보며 가정

`Assertions` 클래스 내부에 `assertRandomNumberInRangeTest`와 `assertRandomUniqueNumbersInRangeTest`가 따로 있는데, 해당 메서드들은 `assertRandomTest`에 `pickNumberInRange`와 `pickUniqueNumbersInRange`를 각각 지정한다.

해당 코드는 `mockStatic(Randoms.class)`로 지정한 mock의 `when`으로 넘어간다. 만약 지정한 메서드가 코드 내에서 동작한다면, 전달받은 `value, values`에 해당하는 값들이 튀어나오는 구조인 것 같다.

#### 실제 찾아보며 확인

우선 [Mock이 무엇인지](https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac)부터 찾아보았다. 해당하는 글을 읽고 Mock이 어떤 형태인지를 (완벽히는 당연히 아니지만) 이해할 수 있었다.

또한 테스트 코드 내부에서 `mockStatic`을 사용했는데, 이는 `Mockito`에서 static 메서드를 mock으로 지정하여 테스트하는 방법이라고 한다.

#### 이런 구조인 것 같은데?

> 이 역시 어디까지나 가정이니, 틀린 부분이 있다면.. 어떻게든 알려주셨으면 좋겠다 ㅠ

`Mockito`를 이용하여 가짜 객체를 생성하고, `해당하는 함수가 돈다면 이러한 결과만을 반환하라`고 지시하는 것 같다. 즉, 해당 테스트는 `pickNumberInRange()` 메서드에 원하는 값들을 출력하도록 한 Mock 객체를 생성한 것이고, `pickUniqueNumbersInRange()`에 대한 지정이 없었으니 반환형에 대한 빈 값이 나오도록 설정되어 있었으며, 따라서 해당 메서드에서는 빈 List 객체가 나왔던 듯 하다.

이후 `pickNumberInRange()`를 사용하는 방향으로 수정한 이후에는, 내가 작성한 main문이 돌 때 `Randoms`클래스 대신 `Randoms` 클래스를 상속받은 Mock 객체를 받아왔고, `pickNumberInRange()`를 호출했을 때 `1, 3, 5, 5, 8, 9`가 차례대로 호출되어 원하는 답이 나오도록 조절된 상태이므로 해당하는 테스트가 정상 수행된 것 같다.

# 리팩터링

## 명확한 의미를 지니도록 하자

- 유저가 입력한 값을 숫자 리스트로 변환받는 메서드명을 `getNumsListIfAcceptable`로 작성했었다. 물론 List로 받는 건 맞지만, 메서드 명만 봐서는 어떠한 의미를 갖는 List를 반환받는지 모를 것 같았다. 따라서 `getUserInputNumbersIfConvertible`로 변경해 주었으며, 관련 메서드명도 해당 규칙에 맞게 변경하였다.
- 0은 허용되지 않은 숫자이다. 0의 사용 유무를 확인하던 메서드는 `validateUse0`이었으며 코드 내에서 0 자체를 놓고 비교하였다. 그러나 이것 또한 매직넘버라 판단하여, 0을 `FORBIDDEN_NUMBER`로 치환하였다.
- `숫자는 1부터 9까지만 사용되어야 합니다. 0을 포함할 수 없습니다.`라는 설명 또한, 범위값과 허용되지 않은 숫자가 변경된다면 같이 바뀌어야 한다고 생각했다. 따라서 `"숫자는 " + START_NUMBER + "부터 " + END_NUMBER + "까지만 사용되어야 합니다. " + FORBIDDEN_NUMBER +"을 포함할 수 없습니다."`라는 코드로 변경하였다.
- 코수타에서도 `i`에 대해 얘기가 나왔던 걸로 기억한다. 보통 인덱스나 특정 숫자의 범위값을 차례로 채우기 위해 사용하는데, 이 또한 `idx`로 명확하게 표현 가능하도록 하였다.
- 사용자가 확실한 정답을 맞추거나(스트라이크), 정확하진 않지만 범위 내의 값을 제시했을 경우(볼) 해당 대답을 정리하는 메서드에서 카운트를 올려주는 방식이었는데, 매개변수 이름을 `answer`로 했었다. 답을 정리하는 건 맞지만 여러 해석이 가능하다고 생각하여 `accuracyResult`로 이름을 변경하였다.
- 외에도 의미가 명확하지 않다고 느끼면 계속 수정했다.

## 클래스를 쪼개는 게 좋을까..?

-  현재 `NumbersBaseballGame` 내에는 많은 메서드가 있다. 크게 세가지로 나눈다면 밑의 내용과 같을 것이다.
   -  목표값을 설정
   -  사용자의 입력을 확인
   -  입력값을 통해 스트라이크, 볼 판단
-  위와 같은 형태를 각각의 클래스로 쪼개어 유지하는 게 좋은 방법일지 많이 고민했다.
   -  장점
      -  게임에 필요한 목표값을 계속 쥐어주는 클래스가 있다면, 목표값의 설정이 바뀌어도 하나의 클래스에서만 신경쓰면 된다.
      -  사용자는 입력을 받는 클래스와 계속 응답을 주고받으며, 검증된 입력을 게임에서 사용한다.
      -  입력값을 스트라이크와 볼을 판단하는 심판 역할의 클래스에게 넘겨주고, 심판의 응답에 따른 결과를 사용자에게 보여준다.
   -  단점
      -  게임은 하나의 룰을 가진 객체다. 목표값의 설정이 바뀐다면 룰이 바뀌는 것이고, 이는 두 클래스를 모두 수정해야 하는 결과를 낳을 수도 있다.
      -  입력 검증 또한 하나의 룰에 기반한 내용이다.
      -  스트라이크와 볼도 마찬가지로 하나의 룰이며, 만약 파울같은 추가적인 설정이 들어간다면 두 클래스를 모두 관리해야 한다.
   -  위와 같은 결과를 도출했기에 따로 분리하지 않기로 했다.
-  전처럼 플레이어와 게임으로 만드는 건 어떨까?
   -  플레이어에게 주어진 룰이 있을까..? 현재 룰을 컨트롤하는 건 게임 자체이다.
   -  엇.. 이렇게 생각하면 1회차의 1번 문제에서 플레이어를 쪼개지 말았어야 하는건가..
      -  여러 명의 플레이어가 존재하고, 플레이어마다 지녀야 할 데이터들이 있었다면 따로 두는 게 맞았을 것 같다. 그러나 해당 문제를 떠올려보면, 굳이 나누지 않아도 되었을지도.. 오히려 쪼개놓은 것 때문에 복잡도를 올렸던 게 아닐까 생각이 든다.
-  그럼 클래스는 언제 쪼개야 하는 것일까..?
   -  **역할이 구분될 때** 클래스를 쪼개야 한다.
   -  현재 `NumbersBaseballGame` 클래스는 유저가 게임을 수행할 수 있게 제공하고 있다. 만약 유저에게 숫자야구를 비롯한 100개의 게임을 제공해야 한다면?
      -  이 때는 게임의 상위 객체를 선언하고, 이를 상속받는 게임들을 만들고.. 분리를 하지 않고서는 메서드가 매우 복잡해질 것이다.
   -  `누군가에게 기능이 부여될 때`로 생각해도 되지 않을까?
      -  위와 같은 예시라고 하면, 여러 게임을 제공하는 `게임기`와, 유저에게 룰을 제공하는 `게임`으로 나뉘게 되는거니까.. 
      -  만약 이렇게 되면, 입력값을 제공받는 기능도 따로 분리되어 게임기에 들어가야 할 것이다.
      -  게임의 룰과 입력값은 계속 상호작용하게 될 것이다. 하지만 게임기 자체에서 입력값(A버튼, B버튼 등)을 제공하여, 올바르지 않은 값을 게임에게 넘기지 않게끔 할 것이고, 게임은 해당 버튼들에 대한 이벤트를 구현하는 걸로 변경될 것 같다.
   -  특정 메서드의 입장에서, 독립적으로 돌아갈 수 있으면 해당 부분이 클래스가 되는 건 아닐까?
      -  여러 객체에게 같은 작업을 부여하는 중복된 메서드가 있다면, 해당 메서드는 따로 클래스로 작성되어 서로의 필요관계에 의한 값을 주고받을 것이다. 메서드의 기능이 전반적인 룰이 되는 것이고, 이는 곧 클래스의 역할이 되는 것이니까..?
-  대충 감은 오는데.. **어렵다.** 아무튼 현재로서는 게임의 전반적인 룰 밑에서 모든 것들이 동작되기에, 클래스를 구분하지 않는 것으로..!

## 상수 집합

![image-20221106142158603](README.assets/image-20221106142158603.png)

토요일에 다른 분들의 리뷰를 보다가, `상수 집합 분리`라는 키워드를 발견했다. Enum을 따로 선언하여 사용하는 걸 말씀하시는 것 같았다.

이번 프로젝트에서 상수를 굉장히 많이 선언하게 되었으므로, 한번 알아보기로 했다.

마침 [우형 기술블로그에 Enum 활용기가 서술되어 있어서](https://techblog.woowahan.com/2527/) 정독 후 참고해보기로 했다.

```java
START_NUMBER(1),
END_NUMBER(1),
PICK_COUNT(3),
FORBIDDEN_NUMBER(0),
DEFAULT_VALUE_IF_KEY_DOES_NOT_EXIST(0),
CORRECT_ANSWER("strike", "스트라이크"),
SIMILAR_ANSWER("ball", "볼"),
WRONG_ANSWER_KOR("낫싱"),
USER_WANT_MORE("1"),
USER_WANT_FINISH("2");
```

그러나 위와 같이 나눠 놓으니, 형식이 너무 제멋대로였기 때문에 `숫자야구 규칙 상수`, `답 정확도 상수`로 나눠놓기로 했다.

헌데 인자를 하나씩만 가진 값들은 오히려 값을 가져오는 메서드를 사용하며 가독성이 저하되는 것 같았다. 따라서 `답 정확도 상수`만 우선 enum으로 선언하고, 나머지는 static class로 해보기로 했다.

헌데 또 막상 나누고 나니 `숫자야구 규칙`, `정확도 판단`, `숫자야구 게임`으로 `클래스를 쪼개는 게 좋을까..?`의 고민내용과 비슷한 형태가 생성된 듯 했다. 또한, `FORBIDDEN_NUMBER`가 규칙에 포함되며 `사용자의 입력 자체를 확인시켜주는 클래스를 짤 수 있을 것 같은데..? 타겟값과 사용자 입력값 관련 규칙만 책임지는 클래스를 만들면, 게임 진행과 따로 분리시켜도 괜찮지 않을까?` 라는 생각을 하게 되었다.

또 이렇게 되니 욕심이 날 수 밖에 없었다. 따라서 시도해보기로 했다.

## 숫자야구 진행, 타겟값 및 입력값 규칙, 정확도 판단의 클래스들

숫자야구를 진행하는 클래스는 변경할 게 없었다. 오히려, 현재 상태에서 메서드들을 덜어내 다른 클래스들에게 쥐어주면 되는 형태였다.

정확도 판단 클래스는 `Referee`라고 명명하여 스트라이크, 볼을 판단하는 심판을 쉽게 떠올릴 수 있게 했다.

다만, 타겟값 및 입력값의 규칙을 제정하고 확인하는 클래스의 이름을 무엇으로 해야 할 지 고민이었다. 단순하게 사용자 입장에선, 플레이어 본인이 투수이니 `Pitcher`라고 지어볼까? 했는데, 타겟값을 설정하는 것까지 들고 있으면 명확한 의미를 주지 못 하는 것 같았다. 그렇다면 포수와 투수를 함께 부르는 `Battery`는 어떨까? 했는데 야구 용어를 모르는 분들은 아예 와닿지 않을 거고, 아는 분들도 갸웃할 것 같았다. 차라리 그렇다면, 야구 게임을 돕는 `Staff`라 한다면 어떨까? 했는데 의외로 괜찮은 것 같아 이대로 진행해보기로 했다.

# 느낀 점

- 코드를 작성하는 시간보다 README의 `구현할 기능 목록`을 고민하고 수정하는 시간이 더 많은 것 같다. 코드를 타이핑하다 보면 빼먹거나 순서를 잘못 생각한 기능들을 파악하게 되고, 해당하는 사항들을 정리하며 머릿속으로 로직을 다시 생각하는 과정이 반복된다. 실력이 증가하는 과정이겠지만, 그동안 정말 대책없이 코드를 작성했구나 하며 반성하게 된다. 